package base

import "fmt"

func ExampleAnonymFunction() {
	f := func(x, y int) int { return x + y }
	// эквивалент :
	// var f func(int, int) int = func(x, y int) int{ return x + y}

	fmt.Println(f(3, 4)) // 7
	fmt.Println(f(6, 7)) // 13

	//--------------------------------------------------------
	//--------------------------------------------------------
	//
	// А Н О Н И М Н А Я    Ф У Н К Ц И Я
	// К А К   А Р Г У М Е Н Т   Д Р У Г О Й     Ф У Н К Ц И И
	//
	//--------------------------------------------------------
	//--------------------------------------------------------

	action := func(n1 int, n2 int, operation func(int, int) int) {

		result := operation(n1, n2)
		fmt.Println(result)
	}

	action(10, 25, func(x int, y int) int { return x + y }) // 35
	action(5, 6, func(x int, y int) int { return x * y })   // 30

	//--------------------------------------------------------
	//--------------------------------------------------------
	//
	// А Н О Н И М Н А Я    Ф У Н К Ц И Я
	// К А К   Р Е З У Л Ь Т А Т   Д Р У Г О Й     Ф У Н К Ц И И
	//
	//--------------------------------------------------------
	//--------------------------------------------------------

	selectFn := func(n int) func(int, int) int {
		if n == 1 {
			return func(x int, y int) int { return x + y }
		} else if n == 2 {
			return func(x int, y int) int { return x - y }
		} else {
			return func(x int, y int) int { return x * y }
		}
	}

	f = selectFn(1)
	fmt.Println(f(2, 3)) // 5
	fmt.Println(f(4, 5)) // 9
	fmt.Println(f(7, 6)) // 13

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//                                                      +
	// Д О С Т У П  К  О К Р У Ж Е Н И Ю                    +
	//                                                      +
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

	// Преимуществом анонимных функций является то, что они имеют доступ к окружению,
	// в котором они определяются. Например:

	fs := square() // на этом моменте была инициализирована переменна Х равная 2
	// она находилась в поле видимости функции square, но так-как fs - есть внутренняя
	// функция square, то она всё еще имеет доступ к этой переменной Х
	//но в самой функции нет доступа к этой переменной Х
	//fmt.Println(x) // вызовит ошибку

	line("ex4")
	fmt.Println(fs()) // 9
	fmt.Println(fs()) // 16 // а на этом моменте
	fmt.Println(fs()) // 25

}

// определяет локальную переменную х
// и
// возвращает анонимную функцию которая имеет доступ к переменной х, увеличивает ее
// на единицу и возвращает её квадрат
func square() func() int {
	var x int = 2
	return func() int {
		x++
		return x * x
	}
}
